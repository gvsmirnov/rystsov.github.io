---
layout: post
title: "Visualization of distributed FSM over Paxos"
name: "Visualization of distributed FSM over Paxos"
tags: ["pre_distr"]
desc: "Step-by-step visualization of distributed FSM over Single Decree Paxos"
has_comments: true
ignore_css: true
marker: vpaxos
---

<div id="vpaxos1" class="brim"><div class="content">
  <h2>Visualization of distributed FSM over Paxos</h2>
  <!-- tweet -->
</div></div>

<div class="brim"><div class="content">
  <p class="edge">The main result of the <a class="link" href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf">Paxos Made Simple<a> paper by Leslie Lamport is an algorithm to transform any <a class="link" href="https://en.wikipedia.org/wiki/Finite-state_machine">finite-state machine (FSM)</a> into a fault-tolerant distributed system.</p>

  <p>It sounds complicated but with the step-by-step <a class="link" href="TODO">vizualization</a> and this post I'm going to demystify its complexity.</p>

  <p>Let us start with FSM. It's a fancy name for a pretty wide class of applications. How wide is it? If you can model your computation as a pure function from a state and an event into a new state and you have a fixed limit on the size of state (and event too) then your computation (your application) is a FSM.</p>

  <p>You can guess that almost any web application using three-tier architecture matches the description: the stateless servers play a role of the pure function while the size of database and the size of http messages have natural upper bounds.</p>

  <p>Now it should be clear <b>why Paxos is important:</b> it allows to convert almost any application into a distributed system to achieve more reliability than the hardware of the individual nodes provides.</p>

  <p>The paper was written in <span class="num">2001</span> and it contains several breakthriught ideas:</p>

  <ul>
    <li>Leslie Lamport shows how to build linearizable distributed data structures:
      <ul>
        <li>a distributed write-once register</li>
        <li>a distributed append-only log</li>
      </ul>
    </li>
    <li>He suggested to use distributed append-only log to store a sequence of events leading to the current state instead of storing the state inself (later this idea rediscovered as the event sourcing pattern).</li>
  </ul>

  <p>In <span class="num">2016</span> it looks natural to use logs for FSM (see ZooKeeper, Etcd, Raft). But logs aren't the first thing that I want to work with as an engineer since they require to implement garbage collection and snapshots (nasty work, see <a class="link" href="http://research.google.com/archive/paxos_made_live.html">Paxos Made Live</a> paper by Google). Since it's possible to imagine how other than logs distribibuted data structures could model FSM I wonder if they really do and why FSMs over them aren't known.</p>

  <ul>
    <li>They do. For example <a class="link" href="http://treode.github.io/">TreodeDB</a> used this approach. It's interesting that I haven't seen any academic paper dedicated to this idea, but I saw several industry systems built with it, so I practiced my math fu, described and proved it in the <a class="link" href="http://rystsov.info/2015/09/16/how-paxos-works.html">How Paxos works</a> post.</li>

    <li>IMHO the log-based solutions are more popular because they simply have time advantage. Until Vertical Paxos was published in <span>2009</span>, log replication was the only consensus protocol capable of cluster membership change thous it was the only practical solution for highly available services. But now we have a couple algorithms to choose from, for example Vertical Paxos and Raft's joint consensus membership change are among them. Take a look on the <a class="link" href="http://rystsov.info/2016/01/05/raft-paxos.html">Best of both worlds: Raft's joint consensus + Single Decree Paxos</a> post if you're interested in understanding how dynamic membership works with a distributed variable.</li>
  </ul>

  <h4>Visualization</h4>

  <p>Now when we understood that there is a place for alternative distributed FSM let's discuss the visualization. We're going to vizualized the work of distributed FSM for an intercontinental ballistic missile launch system.</p>

  <h5>Problem</h5>

  <p>Imagine that we want to model an intercontinental ballistic missile launch system with the following rules:</p>

  <ol>
    <li>The missile is launched when at least two generals signed off the launch.</li>
    <li>Until missile is launched a general can revoke their sign off</li>
  </ol>

  <p>The (non-distributed) FSM engine may look like</p>

  {% gist rystsov/1221d05bebf70197b6dd0b08d335a86a %}

  <p>And the state transition functions are:</p>

  {% gist rystsov/3c3efd10754cc8f585ed5710f9a0cebc %}

  <p>The rules define the possible state of the system; while the actual state is defined by the generals behaviour which is quite simple in our example:</p>

  <ol>
    <li>unsign the launch</li>
    <li>sign the launch</li>
    <li>goto 1</li>
  </ol>

  <h5>Distributed FSM</h5>

  <p>Our goal is to build/vizualize distributed FSM based on Single Decree Paxos.</p>

  <p>From a programmer's perspective distributed FSM is set of nodes with the execute service. Its doesn't matter which nodes are used for each execute service call since the result of execution anyway must correspond to the result of the execution of the same action on the (non-distributed) FSM.</p>

  <p>The hard part of distributed FSM is that it should tolarate node failures message losses.</p>

  <h5>Visualization</h5>

  <p>The vizualization consists of two code columns and the data side view. The first column contains distributed Single Decree Paxos FSM engine (<span>36</span> lines of code); while the second column is dedicated for the state transition functions and the generals behaviour (<span>33</span> lines of code).</p>

  <p>It worths noticing that the state transition functions weren't changed at all, so it extrimly easy to convert existing FSM into DFSM. By the way the actions in the example look like message handlers in the actor model, so FSM over SDP is great way for storing the state of the actors.</p>
</div></div>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>